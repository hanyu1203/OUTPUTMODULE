MODULE BASIC_DATA
IMPLICIT NONE
PRIVATE

PUBLIC :: SP, DP, NM_INT, CORE_DIMENSION, CORE_LAYOUT, LOGO_S, LOGO_S_R, LOGO_S_C

PUBLIC :: MATRIX_OF_CHA, ARRAY_OF_STR, POINTER_ARRAY_OF_STR, STR_MATRIX, DATA_VECTOR, DATA_MATRIX, DATA_BOX, &
          DATA_VECTOR_NODE, DATA_MATRIX_NODE, DATA_BOX_NODE, MATRIX_OF_CHA_NODE

PUBLIC :: APPEND_AFTER_MAT_CHA_LINK
PUBLIC :: CPY_ARY_OF_STR
PUBLIC :: CLEAR_BASIC_DATA

INTEGER, PARAMETER :: INT_EXA = 0
INTEGER, PARAMETER :: SP = SELECTED_REAL_KIND(6,37)
INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(15, 307)
INTEGER, PARAMETER :: K_INT = SELECTED_INT_KIND(4)
INTEGER, PARAMETER :: NM_INT = KIND(INT_EXA)
INTEGER(NM_INT)   :: CORE_DIMENSION
INTEGER(NM_INT), ALLOCATABLE :: CORE_LAYOUT(:, :)
INTEGER(NM_INT)   :: LOGO_S_R, LOGO_S_C
CHARACTER,        ALLOCATABLE :: LOGO_S(:, :)

TYPE MATRIX_OF_CHA
    INTEGER(NM_INT)       :: ROW = 0
    INTEGER(NM_INT)       :: COLUMN = 0
    CHARACTER, ALLOCATABLE :: MATRIX(:, :)
END TYPE

TYPE ARRAY_OF_STR
    INTEGER(NM_INT)       :: LENGTH_OF_STR
    CHARACTER, ALLOCATABLE :: STR(:)
END TYPE

TYPE POINTER_ARRAY_OF_STR
	TYPE(ARRAY_OF_STR), POINTER :: PTR => NULL()
END TYPE

TYPE STR_MATRIX
    INTEGER(NM_INT)                :: ROW_DIMENSION
    INTEGER (NM_INT)               :: COLUMN_DIMENSION
    TYPE(ARRAY_OF_STR), ALLOCATABLE :: MATRIX(:, :)
END TYPE

TYPE DATA_VECTOR
    INTEGER(NM_INT)   , POINTER :: INT_PTR(:) => NULL()
    REAL(DP)          , POINTER :: REL_PTR(:) => NULL()
    TYPE(ARRAY_OF_STR), POINTER :: STR_PTR(:) => NULL()
    INTEGER(NM_INT)            :: DATA_LENGTH
    TYPE(ARRAY_OF_STR)          :: DATA_NAME
END TYPE

TYPE DATA_MATRIX
    INTEGER(NM_INT)   , POINTER :: INT_PTR(:, :) => NULL()
    REAL(DP)          , POINTER :: REL_PTR(:, :) => NULL()
    TYPE(ARRAY_OF_STR), POINTER :: STR_PTR(:, :) => NULL()
    INTEGER(NM_INT)            :: DATA_ROW
    INTEGER(NM_INT)            :: DATA_COLUMN
    TYPE(ARRAY_OF_STR)          :: DATA_NAME
END TYPE

TYPE DATA_BOX
    INTEGER(NM_INT)   , POINTER :: INT_PTR(:, :, :) => NULL()
    REAL(DP)          , POINTER :: REL_PTR(:, :, :)  => NULL()
    TYPE(ARRAY_OF_STR), POINTER :: CHA_PTR(:, :, :) => NULL()
    INTEGER(NM_INT)            :: DATA_SLICE
    INTEGER(NM_INT)            :: DATA_ROW
    INTEGER(NM_INT)            :: DATA_COLUMN
    TYPE(ARRAY_OF_STR)          :: DATA_NAME
END TYPE

TYPE DATA_VECTOR_NODE
    TYPE(DATA_VECTOR)     , POINTER :: VECTOR_NODE
    TYPE(DATA_VECTOR_NODE), POINTER :: NEXT => NULL()
END TYPE

TYPE DATA_MATRIX_NODE
    TYPE(DATA_MATRIX)     , POINTER :: MATRIX_NODE
    TYPE(DATA_MATRIX_NODE), POINTER :: NEXT => NULL()
END TYPE

TYPE DATA_BOX_NODE
    TYPE(DATA_BOX)     , POINTER :: BOX_NODE
    TYPE(DATA_BOX_NODE), POINTER :: NEXT => NULL()
END TYPE

TYPE MATRIX_OF_CHA_NODE
	TYPE(MATRIX_OF_CHA)     , POINTER :: CONTENT => NULL()
	TYPE(MATRIX_OF_CHA_NODE), POINTER :: NEXT => NULL()
END TYPE

INTERFACE CLEAR_BASIC_DATA
	MODULE PROCEDURE CLEAR_MATRIX_OF_CHA
	MODULE PROCEDURE CLEAR_MATRIX_OF_CHA_LINK
	MODULE PROCEDURE CLEAR_ARRAY_OF_STR
	MODULE PROCEDURE CLEAR_PTRARRAY_ARRAY_OF_STR
	MODULE PROCEDURE CLEAR_ARRAY_STR_MATRIX
END INTERFACE CLEAR_BASIC_DATA
	
INTERFACE CPY_ARY_OF_STR
	MODULE PROCEDURE COPY_ARRAY_OF_STR
	MODULE PROCEDURE COPY_TO_ARRAY_OF_STR
END INTERFACE CPY_ARY_OF_STR

CONTAINS
	SUBROUTINE APPEND_AFTER_MAT_CHA_LINK(CONTEXT, TIPS)
		IMPLICIT NONE
		TYPE(MATRIX_OF_CHA_NODE), POINTER, INTENT(IN OUT) :: CONTEXT
		TYPE(MATRIX_OF_CHA)      ,POINTER, INTENT(IN)    :: TIPS
		
		TYPE(MATRIX_OF_CHA_NODE), POINTER :: PTR1, PTR2
		
		NULLIFY(PTR1, PTR2)

 		IF (ASSOCIATED(CONTEXT)) THEN
			PTR1 => CONTEXT
			IF (.NOT. ASSOCIATED(PTR1%NEXT)) THEN
				ALLOCATE(PTR1%NEXT)
				PTR1 => PTR1%NEXT
				PTR1%CONTENT => TIPS
				PTR1%NEXT => NULL()
			ELSE
				PTR2 => PTR1%NEXT
				NULLIFY(PTR1%NEXT)
				ALLOCATE(PTR1%NEXT)
				PTR1 => PTR1%NEXT
				PTR1%CONTENT => TIPS
				PTR1%NEXT => PTR2
			END IF
			CONTEXT => PTR1
		END IF
	END SUBROUTINE APPEND_AFTER_MAT_CHA_LINK

	SUBROUTINE CLEAR_MATRIX_OF_CHA(MAC)
		IMPLICIT NONE
		TYPE(MATRIX_OF_CHA), POINTER, INTENT(IN OUT) :: MAC
		
		IF (ASSOCIATED(MAC)) THEN
			IF (ALLOCATED(MAC%MATRIX)) THEN
				DEALLOCATE(MAC%MATRIX)
			END IF
			DEALLOCATE(MAC)
		END IF
	END SUBROUTINE CLEAR_MATRIX_OF_CHA
	
	RECURSIVE SUBROUTINE CLEAR_MATRIX_OF_CHA_LINK(LINK_HEAD)
		IMPLICIT NONE
		TYPE(MATRIX_OF_CHA_NODE), POINTER, INTENT(IN OUT) :: LINK_HEAD
		
		TYPE(MATRIX_OF_CHA_NODE), POINTER :: PTR1, PTR2
		
		NULLIFY(PTR1, PTR2)
		
		IF (ASSOCIATED(LINK_HEAD)) THEN
			PTR1 => LINK_HEAD
			PTR2 => PTR1%NEXT
			IF (ASSOCIATED(PTR2)) THEN
				CALL CLEAR_MATRIX_OF_CHA_LINK(PTR2)
			ELSE
				CALL CLEAR_MATRIX_OF_CHA(PTR1%CONTENT)
			END IF
		END IF
		
		LINK_HEAD => NULL()
	END SUBROUTINE CLEAR_MATRIX_OF_CHA_LINK
	
	SUBROUTINE COPY_ARRAY_OF_STR(PTR, ASTR)
		IMPLICIT NONE
		TYPE(ARRAY_OF_STR), POINTER, INTENT(IN OUT) :: PTR
		TYPE(ARRAY_OF_STR),          INTENT(IN)     :: ASTR
		
		INTEGER :: I
		
		IF (ALLOCATED(PTR%STR)) THEN
			DEALLOCATE(PTR%STR)
		END IF
		ALLOCATE(PTR%STR(ASTR%LENGTH_OF_STR))
		PTR%LENGTH_OF_STR = ASTR%LENGTH_OF_STR
		DO I = 1, ASTR%LENGTH_OF_STR
			PTR%STR(I) = ASTR%STR(I)
		END DO
	END SUBROUTINE COPY_ARRAY_OF_STR
	
	SUBROUTINE COPY_TO_ARRAY_OF_STR(PTR, STRING)
		IMPLICIT NONE
		TYPE(ARRAY_OF_STR), POINTER, INTENT(IN OUT) :: PTR
		CHARACTER(LEN=*),            INTENT(IN)     :: STRING
		
		INTEGER :: I, LENGTH
		
		LENGTH = LEN(STRING)
		
		IF (.NOT. ASSOCIATED(PTR)) THEN
			ALLOCATE(PTR)
		END IF
		
		IF (ALLOCATED(PTR%STR)) THEN
			DEALLOCATE(PTR%STR)
		END IF
		ALLOCATE(PTR%STR(LENGTH))
		
		PTR%LENGTH_OF_STR = LENGTH
		DO I = 1, LENGTH
			PTR%STR(I) = STRING(I:I)
		END DO
	END SUBROUTINE COPY_TO_ARRAY_OF_STR
	
	SUBROUTINE CLEAR_ARRAY_OF_STR(ASTR)
		IMPLICIT NONE
		TYPE(ARRAY_OF_STR), INTENT(IN OUT) :: ASTR
		
		IF (ALLOCATED(ASTR%STR)) THEN
			DEALLOCATE(ASTR%STR)
		END IF
	END SUBROUTINE CLEAR_ARRAY_OF_STR
		
	SUBROUTINE CLEAR_PTRARRAY_ARRAY_OF_STR(POINTER_ARRAY, LENGTH)
		IMPLICIT NONE
		TYPE(POINTER_ARRAY_OF_STR), ALLOCATABLE, INTENT(IN OUT) :: POINTER_ARRAY(:)
        INTEGER(NM_INT),                        INTENT(IN)     :: LENGTH
        
        INTEGER(NM_INT)  :: I

        DO I = 1, LENGTH
        	IF (ASSOCIATED(POINTER_ARRAY(I)%PTR)) THEN
        		DEALLOCATE(POINTER_ARRAY(I)%PTR)
        	END IF
        END DO
        DEALLOCATE(POINTER_ARRAY)
	END SUBROUTINE CLEAR_PTRARRAY_ARRAY_OF_STR
	
	SUBROUTINE CLEAR_ARRAY_STR_MATRIX(ARRAY_STM, ARR_LEN)
		IMPLICIT NONE
		TYPE(STR_MATRIX), ALLOCATABLE, INTENT(IN OUT) :: ARRAY_STM(:)
		INTEGER(NM_INT),              INTENT(IN)     :: ARR_LEN
		
		INTEGER :: I, J, K
		
		IF (ALLOCATED(ARRAY_STM)) THEN
			DO I = 1, ARR_LEN
				IF (ALLOCATED(ARRAY_STM(I)%MATRIX)) THEN
					DO J = 1, ARRAY_STM(I)%ROW_DIMENSION
						DO K = 1, ARRAY_STM(I)%COLUMN_DIMENSION
							IF (ALLOCATED(ARRAY_STM(I)%MATRIX(K, J)%STR)) THEN
								DEALLOCATE(ARRAY_STM(I)%MATRIX(K, J)%STR)
							END IF
						END DO
					END DO
					DEALLOCATE(ARRAY_STM(I)%MATRIX)
				END IF
			END DO
			DEALLOCATE(ARRAY_STM)
		END IF
	END SUBROUTINE CLEAR_ARRAY_STR_MATRIX

END MODULE BASIC_DATA